import hashlib
import hmac
import requests
import json
from urllib import parse
from requests.adapters import HTTPAdapter
import urllib3
import time

from goto import with_goto

from .config import API_URL, API_VERSION, APIS, BINANCE_API_BASE,BINANCE_WEB_BASE
from util import send_email,log

class Py3Commas:

    def __init__(self, key: str, secret: str):
        if key is None or key == '':
            raise ValueError('Missing key')
        if secret is None or secret == '':
            raise ValueError('Missing secret')

        self.key = key
        self.secret = secret

    def _generate_signature(self, path: str, data: str) -> str:
        byte_key = str.encode(self.secret)
        message = str.encode(API_VERSION + path + data)
        signature = hmac.new(byte_key, message, hashlib.sha256).hexdigest()
        return signature

    # @with_goto
    def _make_request(self, http_method: str, path: str, params: any, payload: any):
        requrll = ''
        if http_method=="GET":
            signature = self._generate_signature(path, params)
            requrll = API_URL + API_VERSION + path + '?' + params
        else:
            querstr=''
            for key in payload.keys():
                if querstr=='':
                    querstr = querstr+str(key)+'='+str(payload[key])
                else:
                    querstr = querstr +'&'+ str(key) + '=' + str(payload[key])
            log("querstr:" + querstr)
            signature = self._generate_signature(path, querstr)
            log("header Signature:" + signature)
            requrll = API_URL + API_VERSION + path+'?'+querstr
        label .begin
        s = requests.Session()
        s.mount('http://', HTTPAdapter(max_retries=3))
        s.mount('https://', HTTPAdapter(max_retries=3))
        try:
            response = s.request(
                method=http_method,
                url=requrll,
                headers={
                    'APIKEY': self.key,
                    'Signature': signature,
                    'Content-Type':'application/x-www-form-urlencoded'
                },
                data=payload  # python 字典 解析 对应Content-Type
                ,timeout=5
            )
            response.raise_for_status()  # 如果响应状态码不是 200，就主动抛出异常
        except requests.RequestException as e:
            log("服务器超时重连3次失败:"+requrll+str(e))
            send_email("服务器超时重连3次失败:"+requrll+str(e))
            print("等待 7s ...重连... ")
            time.sleep(7)
            goto .begin

        json_obj ={}
        try:
            json_obj = json.loads(response.text)
        except (IndexError, IndentationError) as e1:
            log("requrll:" + requrll)
            log("resp:" + response.text)
            log("解析出错" + str(e1))
            send_email("解析出错"+response.text)
            log("等待 3s ...重连... ")
            time.sleep(3)
            goto .begin
        return json_obj

    def request(self, entity: str, action: str = '', _id: str = None, payload: any = None,param: str = ''):
        if entity is None or entity == '':
            raise ValueError('Missing entity')
        if entity not in APIS:
            raise ValueError('Invalid entity')
        if action not in APIS[entity]:
            raise ValueError('Invalid action')

        api = APIS[entity][action]
        api_path = api[1]
        if '{id}' in api_path:
            if _id is None or _id == '':
                raise ValueError('Missing id')
            api_path = api_path.replace('{id}', _id)

        if api_path is None or api_path== '':
            return self._make_request(
                http_method=api[0],
                path=entity,
                params=param,
                payload=payload
            )
        else:
            return self._make_request(
                http_method=api[0],
                path=entity + "/" + api_path,
                params=param,
                payload=payload
            )

    @with_goto
    def request_binance_data(self, http_method: str, path: str, payload: any = None,params: str = ''):
        requrll = ''
        if http_method=="GET":
            signature = self._generate_signature(path, params)
            if params is not None and params !='':
                requrll =BINANCE_API_BASE + path + '?' + params
            else:
                requrll = BINANCE_API_BASE + path
        else:
            querstr=''
            for key in payload.keys():
                if querstr=='':
                    querstr = querstr+str(key)+'='+str(payload[key])
                else:
                    querstr = querstr +'&'+ str(key) + '=' + str(payload[key])
            signature = self._generate_signature(path, querstr)
            log("querstr:" + querstr)
            requrll = BINANCE_API_BASE + path

        label .begin
        # print("2222")
        s = requests.Session()
        s.mount('http://', HTTPAdapter(max_retries=3))
        s.mount('https://', HTTPAdapter(max_retries=3))
        try:
            response = s.request(
                method=http_method,
                url=requrll,
                headers={
                    'APIKEY': self.key,
                    'Signature': signature,
                    'Content-Type':'application/x-www-form-urlencoded'
                },
                data=payload  # python 字典 解析 对应Content-Type
                ,timeout=(3,2)
            )
            response.raise_for_status()  # 如果响应状态码不是 200，就主动抛出异常
        except requests.RequestException as e:
            log("服务器超时重连4次失败:" + requrll + str(e))
            send_email("服务器超时重连3次失败:"+requrll+str(e))
            log("等待 7s ...重连... ")
            time.sleep(7)
            goto .begin
        log("requrll:" + requrll)
        json_obj ={}
        try:
            json_obj = json.loads(response.text)
        except (IndexError, IndentationError) as e1:
            log("requrll:" + requrll)
            log("resp:" + response.text)
            log("解析出错" + str(e1))
            send_email("解析出错"+response.text)
            log("等待 3s ...重连... ")
            time.sleep(3)
            goto .begin
        return json_obj

    @with_goto
    def get_binance_web_data(self, http_method: str, path: str, payload: any = None,params: str = ''):
        requrll = ''
        if http_method=="GET":
            signature = self._generate_signature(path, params)
            if params is not None and params !='':
                requrll =BINANCE_WEB_BASE + path + '?' + params
            else:
                requrll = BINANCE_WEB_BASE + path
        else:
            querstr=''
            for key in payload.keys():
                if querstr=='':
                    querstr = querstr+str(key)+'='+str(payload[key])
                else:
                    querstr = querstr +'&'+ str(key) + '=' + str(payload[key])
            signature = self._generate_signature(path, querstr)
            log("querstr:" + querstr)
            requrll = BINANCE_API_BASE + path

        label .begin
        s = requests.Session()
        s.mount('http://', HTTPAdapter(max_retries=3))
        s.mount('https://', HTTPAdapter(max_retries=3))
        try:
            response = s.request(
                method=http_method,
                url=requrll,
                headers={
                    # 'APIKEY': self.key,
                    # 'Signature': signature,
                    # 'Content-Type':'application/x-www-form-urlencoded',
                    'lang':'zh-CN'
                },
                data=payload  # python 字典 解析 对应Content-Type
                ,timeout=(3,2)
            )
            response.raise_for_status()  # 如果响应状态码不是 200，就主动抛出异常
        except requests.RequestException as e:
            log("服务器超时重连4次失败:" + requrll + str(e))
            send_email("服务器超时重连3次失败:"+requrll+str(e))
            log("等待 10s ...重连... ")
            time.sleep(10)
            goto .begin
        log("requrll:" + requrll)
        json_obj ={}
        try:
            json_obj = json.loads(response.text)
        except (IndexError, IndentationError) as e1:
            log("requrll:" + requrll)
            log("resp:" + response.text)
            log("解析出错" + str(e1))
            send_email("解析出错"+response.text)
            log("等待 5s ...重连... ")
            time.sleep(5)
            goto .begin
        return json_obj
